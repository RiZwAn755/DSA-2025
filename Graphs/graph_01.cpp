

                                //   graphs  --> function of(vertices and edges)

                                // terms 
                                // sparce and dense graph 
                                
                                // low edges count  --> sparce graph   -->  edges < n^(3/2)
                                // high edges count --> dense graph    ---> edges  > n^(3/2)
                                // number of possible edges = nC2;
                                
                                // degree - defined for each node
                                //  sum of degree = 2*|edges count| 
                                
                                //  indegree , outdegree  for directed graphs
                                // sum of indegree + sum of outdegree == 2*|edge count |
                                
                                // path : sequence of nodes to reach from one node to another
                                
                                // cycle : if u can reach the same node from where u started without travesring any edge twce 
                                // then it means ur grapgh have a cycle
                                
                                // reachable(st , en) 
                                
                                
                                // bipartite graph : if u can color the graph with two colors such that no two neighbours have same colors
                                
                                // simple graph : 
                             //    multi graph : either self loop or more than two edges between any two nodes
                             
                                //   hameltonian path : 
                                
                                // (DAG): directed acyclic grapgh: 
                                
                                // DFS => T.C = O(N + 2M) => N for nodes and 2M int for loop 
                                // DFS => S.C = O(N)  => for storing visited nodes

                                // BFS => T.C = O(N + 2M) => N for nodes and 2M int for loop 
                                // BFS => S.C = O(N ) => N for visited array
                                
                            

                            //  1. input of graph 
                            //  2. graph traversal
                            // 3. dfs and bfs
                            //  4. dfs application
                            //  5. topological sort
                            // 6.shortest path (o1 bfs , bellmanford , dijkstra , floyd warshall)
                            
                            






